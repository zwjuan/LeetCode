链表题库
* 比较顺序表和链表的优缺点，说说它们分别在什么场景下使用？
            a. 顺序表支持随机访问，单链表不支持随机访问。
            b. 顺序表插入/删除数据效率很低，时间复杂度为O(N)（除尾插尾删），单链表插入/删除效率跟高，时间复杂度为O（1）。
            c. 顺序表的CPU高速缓存效率更高，单链表CPU高度缓存效率低。

* 从尾到头打印单链表
             借助stack、递归
* 删除一个无头单链表的非尾节点
            a. 删除头节点  head = head.next  b。中间节点： 找到这个节点，连接前一个节点和后一个节点
* 在无头单链表的一个非头节点前插入一个节点
            找到要插入的位置，记录前一个节点和后一个节点。插入
* 单链表实现约瑟夫环
* 逆置/反转单链表
            解法一：定义三个变量 pre cur next
            解法二：定义一个newNode节点
            指定区间内链表反转 - 思路穿针引线法
* 单链表排序（冒泡排序 & 快速排序）
* 合并两个有序链表，合并后依然有序
            无头指针，空间复杂度O(1)
* 查找单链表的中间节点，要求只能遍历一次链表
            快慢指针，快指针多走一步，当快指针到达链表尾部时，慢指针指向的即为中间节点
* 查找单链表的倒数第K个节点，要求只能遍历一次链表
            快慢指针， 快指针开始先走k步，当快指针到达链表尾部时，慢指针即为倒数第k个节点
* 判断单链表是否带环？若带环，求环的长度？求环的入口节点。并计算每个算法的时间复杂度和空间复杂度。
            a. 快慢指针，如果两个指针相遇，即链表带环。
            b. 相遇后再相遇时，即为环的长度。(慢指针走一圈才可和快指针相遇)
            c.  定义头节点走的指针和慢指针，两个指针相遇的节点即为入口节点。
* 判断两个链表是否相交，若相交，求交点。（假设链表不带环）
            两个链表相交，即尾节点相同。
            a. 求两个链表的总长度，求两个之差。 b. 短链表先走两个之差  c. 遍历链表判断两个链表是否存在交点。

* 判断两个链表是否相交，若相交，求交点。（假设链表可能带环）【升级版】
* 复杂链表的复制。一个链表的每个节点，有一个指向next指针指向下一个节点，还有一个random指针指向这个链表中的一个随机节点或者NULL，现在要求实现复制这个链表，返回复制后的新链表。

* 求两个已排序单链表中相同的数据。void UnionSet(Node* l1, Node* l2);
* 指定区间链表反转
